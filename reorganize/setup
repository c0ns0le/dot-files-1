#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'
require 'awesome_print'

# <<-"OLD_v1"
# plain_srcs = %w{ vim }
# dot_srcs = %w{ vim/dot }
#
# case shell
# when /fish/i
#   plain_srcs << 'fish'
#   dot_srcs << 'fish/dot'
# when /bash/i
#   plain_srcs << 'bash'
#   dot_srcs << 'bash/dot'
# when /zsh/i
#   plain_srcs << 'zsh'
#   dot_srcs << 'zsh/dot'
# end
# OLD_v1
#
# puts <<"THE_PLAN"
#
#   So I think there should be 3 sections for each subsection:
#
#   1. files that automatically loaded by the app, boilerplate
#   if you will, (.vimrc/.vim, .bashrc, .zshrc, etc.)
#
#   1. then, maybe just a folder that goes in `~/.config/`
#
#   The boilerplate stuff can even got in a `dot/` folder
#   inside the `~/.config/` folder, but is then symlinked out.
#
#   So maybe it would look like this:
#
#   vim/
#   vim/dot/
#   vim/dot/vim/
#   vim/dot/vimrc
#   vim/hashrocket
#   vim/local
#   vim/bundles/
#
#   bash/
#   bash/dot/
#   bash/dot/bashrc
#   bash/dot/bash_profile
#   bash/local
#   bash/paths
#   bash/git
#   bash/ruby
#
#   if `dot/` has a `no_dot` file, anything listed in there
#   will be linked w/out being renamed
#
#   brew/dot/
#   brew/dot/no_dot
#   brew/dot/Brewfile
#
# THE_PLAN

class Dotfiles
  attr_accessor :args, :shell, :shells,
  :pwd, :home, :base, :base_backup, :dots_backup, :now,
  :debug, :file_opts

  def self.setup(args=ARGV.clone)
    Dotfiles.new(args).tap(&:setup)
  end

  def initialize(args=ARGV.clone)
    @args = args
    @debug = false
    @file_opts = {}

    @shells = %w{ bash zsh fish }

    @shell = File.basename ENV['SHELL']

    @now = Time.now.to_i

    @pwd = Dir.pwd
    @home = ENV['HOME']
    @base = format('%s/.config', home)
    @base_backup = format('%s/config.%s', home, now)
    @dots_backup = format('%s/dots.%s', home, now)
  end

  def shell
    parse_options
    @shell = args.first if shells.include? args.first
    @shell
  end

  def ignored_shells
    ap in: :ignored_shells, shells: @shells, shell: shell
    @shells.select{|sh| sh != shell }
  end

  def link(src,dest)
    printf "linking '%s' to '%s' ...\n", src, dest

    if File.directory? src
      FileUtils.ln_s(src, dest, file_opts)
    else
      FileUtils.ln(src, dest, file_opts)
    end
  end

  def file_opts
    parse_options
    @file_opts
  end

  def setup
    if Dir.pwd != base
      FileUtils.rm(base, file_opts) if File.symlink? base
      FileUtils.mv(base, base_backup, file_opts) if File.exist? base
      FileUtils.mkdir_p(dots_backup, file_opts)
      FileUtils.ln_s pwd, base, file_opts
    end

    Dir.chdir base if debug == false

    # loop thru each `*/dot/` that is not in shells
    #
    # check for the existence of setup.yml
    #
    # load the files either renaming them all, or using the
    # custom naming defined in setup.yml
    ap ignored_shells: ignored_shells
    dirs = Dir['*/'].reject{|dir| ignored_shells.include? File.basename(dir) }
    ap dirs: dirs
    dirs.each do |dir|
      dotdir = File.join(dir, 'dot')

      no_dot = format '%s/no_dot', dotdir

      no_dots = File.exist?(no_dot)
      no_dots &&= IO.read(no_dot).split(/\s*\n+\s*/)
      no_dots ||= []

      Dir[format '%s/*', dotdir].select{|df| File.basename(df) != 'no_dot' }.each do |dot|
        dest = File.basename dot
        dest = ?. + dest unless no_dots.include? dest
        dest = format '%s/%s', home, dest

        FileUtils.mv [dest], dots_backup, file_opts if File.exist? dest

        link dot, dest
      end
    end
  end

  def parse_options
    return args if @options_parsed == true
    @options_parsed = true
    args.options do |opts|
      opts.on('-d', '--debug', 'see: dry-run') do
        @debug = true
        @file_opts.merge! noop: true
      end

      opts.on('-n', '--dry-run', 'do not perform any file operations') do
        @debug = true
        @file_opts.merge! noop: true
      end

      opts.on('-v', '--verbose') do
        @file_opts.merge! verbose: true
      end

      opts.on('-s', '--shell SHELL') do |sh|
        @shell = sh
      end

      opts.on('-b', '--bash') do
        @shell = 'bash'
      end

      opts.on('-z', '--zsh') do
        @shell = 'zsh'
      end

      opts.on('-f', '--fish') do
        @shell = 'fish'
      end
    end.parse!
  end
end

Dotfiles.setup ARGV

